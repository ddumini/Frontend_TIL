# 렌더링 방식

웹 애플리케이션의 렌더링 방식은 사용자 경험, 성능, SEO에 큰 영향을 미치는 핵심 개념이다. 각 방식의 특징과 적절한 사용 시나리오를 이해하여 프로젝트에 최적화된 선택을 할 수 있다.

## 목차

1. [클라이언트 사이드 렌더링 (CSR)](#1-클라이언트-사이드-렌더링-csr)
2. [서버 사이드 렌더링 (SSR)](#2-서버-사이드-렌더링-ssr)
3. [정적 사이트 생성 (SSG)](#3-정적-사이트-생성-ssg)
4. [점진적 정적 재생성 (ISR)](#4-점진적-정적-재생성-isr)
5. [온디맨드 재생성 (On-Demand ISR)](#5-온디맨드-재생성-on-demand-isr)
6. [렌더링 방식 비교 및 선택 가이드](#6-렌더링-방식-비교-및-선택-가이드)

---

## 1. 클라이언트 사이드 렌더링 (CSR)

### 개념

CSR은 브라우저에서 JavaScript를 실행하여 페이지를 동적으로 생성하는 방식이다. 서버는 최소한의 HTML과 JavaScript 번들을 전달하고, 클라이언트가 모든 렌더링 작업을 담당한다. React, Vue.js, Angular 등의 SPA(Single Page Application) 프레임워크에서 주로 사용되며, Create React App으로 생성된 애플리케이션이 대표적인 예시다.

### 동작 과정

```
1. 사용자가 페이지 요청
2. 서버가 최소한의 HTML + JavaScript 번들 전송
3. 브라우저가 JavaScript 다운로드 및 실행
4. API 호출로 데이터 가져오기
5. 동적으로 DOM 생성 및 렌더링
```

### 예시 코드

```jsx
// React CSR 예시
function App() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 클라이언트에서 데이터 페칭
    fetch('/api/posts')
      .then((res) => res.json())
      .then((data) => {
        setPosts(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}
```

### 장점

- **빠른 페이지 전환**: 한 번 로드 후 SPA 방식으로 빠른 네비게이션
- **서버 부하 감소**: 렌더링 작업을 클라이언트에 위임
- **풍부한 상호작용**: 복잡한 UI/UX 구현에 적합

### 단점

- **초기 로딩 지연**: JavaScript 번들 다운로드 및 실행 시간 필요
- **SEO 문제**: 검색 엔진이 빈 HTML을 받아 콘텐츠 인덱싱 어려움
- **성능 의존성**: 사용자 디바이스 성능에 따라 렌더링 속도 차이

### 단점 해결 방법

#### 1. 코드 스플리팅 (Code Splitting)

```jsx
// React.lazy를 사용한 동적 임포트
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

#### 2. 프리렌더링 (Prerendering)

```javascript
// react-snap을 사용한 프리렌더링
// package.json
{
  "scripts": {
    "postbuild": "react-snap"
  },
  "reactSnap": {
    "puppeteerArgs": ["--no-sandbox"]
  }
}
```

---

## 2. 서버 사이드 렌더링 (SSR)

### 개념

#### 전통적인 SSR (Vanilla JS 기반)

전통적인 웹 개발에서 SSR은 서버에서 완전한 HTML 페이지를 생성하여 클라이언트에 전달하는 방식이다. PHP, JSP, ASP.NET 등의 서버 사이드 언어로 개발된 웹사이트가 이에 해당한다. 각 페이지 요청마다 서버에서 새로운 HTML을 생성하고 전체 페이지를 새로고침한다.

#### 모던 SSR (Next.js 관점)

Next.js에서의 SSR은 React 컴포넌트를 서버에서 HTML로 렌더링한 후 클라이언트에 전달하는 방식이다. 초기 로딩은 서버에서 처리하고, 이후 상호작용은 클라이언트에서 처리하는 하이브리드 방식이다. `getServerSideProps` 함수를 통해 각 요청마다 서버에서 데이터를 가져와 페이지를 렌더링한다.

### 동작 과정

```
1. 사용자가 페이지 요청
2. 서버에서 데이터 페칭
3. 서버에서 HTML 렌더링
4. 완성된 HTML을 클라이언트에 전송
5. 브라우저가 HTML 표시 (First Paint)
6. JavaScript 하이드레이션 (상호작용 가능)
```

### 예시 코드

```jsx
// Next.js SSR 예시
export async function getServerSideProps(context) {
  // 서버에서 데이터 페칭
  const res = await fetch(`${process.env.API_URL}/posts`);
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

function PostsPage({ posts }) {
  return (
    <div>
      <h1>게시글 목록</h1>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}

export default PostsPage;
```

### 장점

- **빠른 초기 로딩**: 완성된 HTML을 즉시 표시
- **SEO 친화적**: 검색 엔진이 완전한 콘텐츠 인덱싱 가능
- **소셜 미디어 최적화**: 메타 태그가 포함된 HTML 제공

### 단점

- **서버 부하 증가**: 각 요청마다 서버에서 렌더링 수행
- **TTFB 지연**: 서버 처리 시간으로 인한 첫 바이트 도달 시간 증가
- **복잡성**: 서버와 클라이언트 환경 차이로 인한 개발 복잡도 증가

### 단점 해결 방법

#### 1. 캐싱 전략

```javascript
// Next.js에서 캐시 헤더 설정
export async function getServerSideProps(context) {
  // 캐시 헤더 설정
  context.res.setHeader('Cache-Control', 'public, s-maxage=10, stale-while-revalidate=59');

  const posts = await fetchPosts();

  return { props: { posts } };
}
```

#### 2. 스트리밍 SSR

```jsx
// React 18 Streaming SSR
import { renderToPipeableStream } from 'react-dom/server';

function streamApp(req, res) {
  const stream = renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader('Content-Type', 'text/html');
      stream.pipe(res);
    },
  });
}
```

---

## 3. 정적 사이트 생성 (SSG)

### 개념

SSG는 빌드 시점에 모든 페이지를 미리 정적 HTML로 생성하여 배포하는 방식이다. CDN을 통해 전 세계 어디서나 빠르게 콘텐츠를 제공할 수 있다. Gatsby, Next.js의 `getStaticProps`, Jekyll, Hugo 등에서 사용되며, GitHub Pages나 Netlify 같은 정적 호스팅 서비스에 배포하기 적합하다.

### 등장 배경

SSG는 다음 문제들을 해결하기 위해 등장했다:

- **CSR의 SEO 문제**: 검색 엔진 최적화 필요성
- **SSR의 서버 부하**: 매 요청마다 렌더링하는 비효율성
- **성능 최적화**: 가장 빠른 로딩 속도 제공 필요성

### 동작 과정

```
1. 빌드 시점에 모든 데이터 수집
2. 각 페이지별 정적 HTML 생성
3. 정적 파일들을 CDN에 배포
4. 사용자 요청 시 CDN에서 즉시 HTML 제공
```

### 예시 코드

```jsx
// Next.js SSG 예시
export async function getStaticProps() {
  // 빌드 시점에 데이터 페칭
  const posts = await fetch(`${process.env.API_URL}/posts`).then((res) => res.json());

  return {
    props: {
      posts,
    },
    // 24시간마다 재생성 (ISR)
    revalidate: 86400,
  };
}

export async function getStaticPaths() {
  // 미리 생성할 경로들 정의
  const posts = await fetch(`${process.env.API_URL}/posts`).then((res) => res.json());

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return {
    paths,
    fallback: 'blocking', // 없는 경로는 요청 시 생성
  };
}

function PostPage({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}

export default PostPage;
```

### 장점

- **최고의 성능**: 정적 파일 제공으로 가장 빠른 로딩
- **SEO 최적화**: 완전한 HTML 제공
- **서버 부하 없음**: 정적 파일 서빙만 필요
- **높은 가용성**: CDN 분산으로 안정적 서비스

### 단점

- **실시간 데이터 한계**: 빌드 시점 데이터만 반영
- **빌드 시간 증가**: 페이지 수에 비례한 빌드 시간
- **동적 기능 제약**: 사용자별 개인화 어려움

### 단점 해결 방법

#### 1. 하이브리드 접근

```jsx
// 정적 콘텐츠 + 동적 데이터 조합
function ProductPage({ product }) {
  const [reviews, setReviews] = useState([]);

  useEffect(() => {
    // 클라이언트에서 동적 데이터 로드
    fetchReviews(product.id).then(setReviews);
  }, [product.id]);

  return (
    <div>
      {/* 정적 콘텐츠 */}
      <h1>{product.name}</h1>
      <p>{product.description}</p>

      {/* 동적 콘텐츠 */}
      <ReviewList reviews={reviews} />
    </div>
  );
}
```

#### 2. 점진적 정적 재생성 (ISR)으로 전환

---

## 4. 점진적 정적 재생성 (ISR)

### 개념

ISR은 SSG의 성능 이점을 유지하면서 실시간 데이터 업데이트 문제를 해결하기 위해 등장한 방식이다. 정적 페이지를 일정 주기로 백그라운드에서 재생성하여 최신 데이터를 반영한다. Next.js 9.5에서 도입되었으며, Gatsby의 Incremental Builds와 유사한 개념이다.

### 등장 배경

ISR은 SSG의 다음 한계를 극복하기 위해 개발되었다:

- **데이터 신선도**: 빌드 후 데이터 변경 반영 불가
- **전체 재빌드 비용**: 일부 페이지 변경을 위한 전체 사이트 재빌드
- **확장성 문제**: 대규모 사이트의 빌드 시간 증가

### 동작 과정

```
1. 사용자가 페이지 요청
2. 캐시된 정적 페이지 즉시 제공 (Stale)
3. 백그라운드에서 페이지 재생성 확인
4. revalidate 시간 초과 시 새 버전 생성
5. 다음 요청부터 새 버전 제공 (Fresh)
```

### 예시 코드

```jsx
// Next.js ISR 예시
export async function getStaticProps() {
  const posts = await fetch(`${process.env.API_URL}/posts`).then((res) => res.json());

  return {
    props: {
      posts,
      lastUpdated: new Date().toISOString(),
    },
    // 60초마다 재생성 시도
    revalidate: 60,
  };
}

function BlogPage({ posts, lastUpdated }) {
  return (
    <div>
      <h1>블로그</h1>
      <p>마지막 업데이트: {new Date(lastUpdated).toLocaleString()}</p>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

export default BlogPage;
```

### 구현 방법

#### Next.js에서 ISR 구현

```javascript
// 1. getStaticProps에서 revalidate 설정
export async function getStaticProps() {
  return {
    props: { data },
    revalidate: 3600, // 1시간마다 재생성
  };
}

// 2. Fallback 전략 설정
export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking', // 또는 true
  };
}
```

### 장점

- **성능 + 신선도**: SSG의 빠른 로딩 + 최신 데이터
- **서버 효율성**: 필요한 페이지만 재생성
- **사용자 경험**: 항상 빠른 응답 (stale-while-revalidate)
- **확장성**: 대규모 사이트에서도 효율적

### 단점

- **복잡성**: 캐시 무효화 전략 필요
- **일관성 문제**: 재생성 중 다른 버전 제공 가능
- **예측 어려움**: 정확한 업데이트 시점 제어 어려움

### 단점 해결 방법

#### 1. 적절한 revalidate 시간 설정

```javascript
// 콘텐츠 특성에 따른 revalidate 시간 설정
export async function getStaticProps() {
  const contentType = getContentType();

  let revalidate;
  switch (contentType) {
    case 'news':
      revalidate = 300; // 5분
      break;
    case 'blog':
      revalidate = 3600; // 1시간
      break;
    case 'documentation':
      revalidate = 86400; // 24시간
      break;
    default:
      revalidate = 1800; // 30분
  }

  return {
    props: { data },
    revalidate,
  };
}
```

---

## 5. 온디맨드 재생성 (On-Demand ISR)

### 개념

온디맨드 ISR은 정해진 시간 간격이 아닌, 특정 이벤트나 요청에 따라 즉시 페이지를 재생성하는 방식이다. 데이터 변경 시점에 정확히 페이지를 업데이트할 수 있다. Next.js 12.1에서 도입되었으며, Webhook이나 API 호출을 통해 트리거된다.

### 등장 배경

기존 ISR의 한계를 해결하기 위해 등장했다:

- **시간 기반 한계**: 정해진 시간까지 기다려야 하는 문제
- **불필요한 재생성**: 데이터 변경이 없어도 주기적 재생성
- **즉시성 요구**: 중요한 업데이트의 즉시 반영 필요

### 동작 과정

```
1. 콘텐츠 관리자가 데이터 업데이트
2. Webhook 또는 API 호출로 재생성 요청
3. 특정 페이지 즉시 재생성
4. 새로운 정적 페이지 배포
5. 다음 요청부터 업데이트된 콘텐츠 제공
```

### 예시 코드

#### Next.js 온디맨드 ISR

```javascript
// pages/api/revalidate.js
export default async function handler(req, res) {
  // 보안 토큰 검증
  if (req.query.secret !== process.env.REVALIDATE_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  try {
    // 특정 경로 재생성
    const { path } = req.body;
    await res.revalidate(path);

    return res.json({
      revalidated: true,
      path,
      timestamp: new Date().toISOString(),
    });
  } catch (err) {
    console.error('Revalidation error:', err);
    return res.status(500).send('Error revalidating');
  }
}
```

#### CMS Webhook 연동

```javascript
// Strapi, Contentful 등 CMS와 연동
export default async function webhookHandler(req, res) {
  const { model, entry } = req.body;

  try {
    // 모델별 재생성 경로 결정
    const pathsToRevalidate = getPathsForModel(model, entry);

    // 병렬로 여러 경로 재생성
    await Promise.all(pathsToRevalidate.map((path) => res.revalidate(path)));

    res.json({
      success: true,
      revalidated: pathsToRevalidate,
    });
  } catch (error) {
    res.status(500).json({ error: 'Revalidation failed' });
  }
}

function getPathsForModel(model, entry) {
  switch (model) {
    case 'blog-post':
      return [`/blog/${entry.slug}`, '/blog', '/'];
    case 'product':
      return [`/products/${entry.id}`, '/products', `/categories/${entry.category.slug}`];
    default:
      return ['/'];
  }
}
```

### 구현 방법

#### 1. API 라우트 설정

```javascript
// Next.js API 라우트
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { paths, secret } = req.body;

  if (secret !== process.env.REVALIDATE_SECRET) {
    return res.status(401).json({ message: 'Invalid secret' });
  }

  try {
    await Promise.all(paths.map((path) => res.revalidate(path)));
    res.json({ revalidated: true });
  } catch (err) {
    res.status(500).send('Error revalidating');
  }
}
```

#### 2. 클라이언트에서 재생성 트리거

```javascript
// 관리자 패널에서 재생성 버튼
async function triggerRevalidation(paths) {
  const response = await fetch('/api/revalidate', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      paths,
      secret: process.env.NEXT_PUBLIC_REVALIDATE_SECRET,
    }),
  });

  if (response.ok) {
    alert('페이지가 성공적으로 업데이트되었다!');
  }
}
```

### 장점

- **즉시성**: 데이터 변경 즉시 반영
- **효율성**: 필요한 경우에만 재생성
- **정확성**: 정확한 타이밍에 업데이트
- **비용 절약**: 불필요한 재생성 방지

### 단점

- **구현 복잡도**: 추가적인 인프라 설정 필요
- **보안 고려사항**: API 엔드포인트 보안 필요
- **의존성**: 외부 시스템과의 연동 필요

---

## 6. 렌더링 방식 비교 및 선택 가이드

### 성능 비교표

| 특성           | CSR  | SSR  | SSG       | ISR       |
| -------------- | ---- | ---- | --------- | --------- |
| 초기 로딩 속도 | 느림 | 빠름 | 매우 빠름 | 매우 빠름 |
| SEO            | 나쁨 | 좋음 | 매우 좋음 | 매우 좋음 |
| 서버 부하      | 낮음 | 높음 | 매우 낮음 | 낮음      |
| 실시간 데이터  | 좋음 | 좋음 | 나쁨      | 보통      |
| 개발 복잡도    | 낮음 | 높음 | 보통      | 높음      |
| 빌드 시간      | 빠름 | 빠름 | 느림      | 보통      |

### 선택 가이드

#### CSR을 선택해야 하는 경우

- **대시보드, 관리자 패널**: 복잡한 상호작용이 많은 애플리케이션
- **개인화된 콘텐츠**: 사용자별 맞춤 콘텐츠가 주요한 서비스
- **실시간 업데이트**: 채팅, 실시간 데이터 시각화

```jsx
// 예시: 실시간 대시보드
function Dashboard() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080');
    ws.onmessage = (event) => {
      setData(JSON.parse(event.data));
    };
  }, []);

  return <RealTimeChart data={data} />;
}
```

#### SSR을 선택해야 하는 경우

- **전자상거래**: 상품 페이지, 검색 결과
- **뉴스 사이트**: 최신 기사, 실시간 업데이트 필요
- **소셜 미디어**: 공유 시 메타데이터 중요

```jsx
// 예시: 상품 상세 페이지
export async function getServerSideProps({ params }) {
  const product = await fetchProduct(params.id);
  const reviews = await fetchReviews(params.id);

  return {
    props: { product, reviews },
  };
}
```

#### SSG를 선택해야 하는 경우

- **블로그, 문서 사이트**: 정적 콘텐츠 중심
- **마케팅 페이지**: 랜딩 페이지, 회사 소개
- **포트폴리오**: 개인 웹사이트, 작품 전시

```jsx
// 예시: 블로그 포스트
export async function getStaticProps() {
  const posts = await fetchAllPosts();

  return {
    props: { posts },
    revalidate: false, // 완전 정적
  };
}
```

#### ISR을 선택해야 하는 경우

- **콘텐츠 사이트**: 주기적 업데이트가 있는 블로그
- **제품 카탈로그**: 재고, 가격 정보 업데이트
- **이벤트 페이지**: 일정한 주기로 정보 변경

```jsx
// 예시: 제품 목록
export async function getStaticProps() {
  const products = await fetchProducts();

  return {
    props: { products },
    revalidate: 3600, // 1시간마다 업데이트
  };
}
```

### 하이브리드 접근법

실제 프로젝트에서는 여러 렌더링 방식을 조합하여 사용하는 것이 일반적이다:

```jsx
// Next.js 하이브리드 예시
// pages/index.js - SSG (홈페이지)
export async function getStaticProps() {
  return { props: { hero: await fetchHeroData() } };
}

// pages/blog/[slug].js - ISR (블로그)
export async function getStaticProps() {
  return {
    props: { post: await fetchPost() },
    revalidate: 3600,
  };
}

// pages/dashboard.js - CSR (대시보드)
function Dashboard() {
  // 클라이언트 사이드 렌더링
}

// pages/products/[id].js - SSR (상품 상세)
export async function getServerSideProps() {
  return { props: { product: await fetchProduct() } };
}
```

### 성능 최적화 팁

1. **적절한 캐싱 전략**

```javascript
// Cache-Control 헤더 설정
res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate=300');
```

2. **이미지 최적화**

```jsx
import Image from 'next/image';

<Image
  src='/hero.jpg'
  alt='Hero image'
  width={800}
  height={400}
  priority // LCP 최적화
/>;
```

3. **코드 스플리팅**

```jsx
const DynamicComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <p>Loading...</p>,
});
```

각 렌더링 방식은 고유한 장단점을 가지고 있으며, 프로젝트의 요구사항에 따라 적절한 선택이 필요하다. 성능, SEO, 개발 복잡도, 사용자 경험을 종합적으로 고려하여 최적의 렌더링 전략을 수립해야 한다.
