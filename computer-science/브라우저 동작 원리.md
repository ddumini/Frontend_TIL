# 브라우저 동작 원리  

## 웹 브라우저란?
웹 브라우저란 웹 서버에서 양방향 통신을 하며 정보를 탐색하고 
HTML 문서, 이미지 등 여러 콘텐츠를 사용자에게 표현해주는 GUI 기반 소프트웨어로 크롬, 사파리, 파이어폭스, 엣지 등이 있다.

브라우저는 페이지를 다운로드하기 위해 응용 계층의 HTTP 프로토콜을 이용해 데이터를 송신/수신한다.

브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다.
자원은 보통 HTML 문서지만 다른 형태일 수 있다(PDF, 멀티미디어 등).
자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.
브라우저는 HTML과 CSS 명세에 따라 HTML 파일을 해석해서 표시하는데 
이 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium)에서 정의하고 있다.

## 브라우저의 기본 구조
![브라우저 동작 원리 다이어그램](/images/images_browser_structure.png)

### 1. 사용자 인터페이스
- viewport를 제외한 모든 부분
- 주소 표시줄, 북마크 메뉴, 탭 목록 등
- 프로그램 자체의 GUI를 구성하는 부분이다.

### 2. 브라우저 엔진
- 사용자 인터페이스와 렌더링 엔진 사이 동작을 제어
- URL을 로드하거나 새로 고침, 뒤로 가기 등을 실행하는 메서드를 제공

### 3. 렌더링 엔진
- 사용자가 요청한 리소스를 파싱하여 화면에 표시

### 4. 통신
- 렌더링 엔진으로부터 HTTP 요청을 받아 서버에 요청하고 응답 리소스를 렌더링 엔진에 반환

### 5. JavaScript 엔진
- JavaScript 코드를 해석하고 실행

### 6. UI 백엔드
- select, input과 같은 기본 위젯을 그린다.
- UI는 OS체계를 따른다.

### 7. 자료 저장소
- 사용자의 컴퓨터에 데이터를 저장하고 접근
- 쿠키, 세션, 로컬 스토리지, IndexedDB 등

## 브라우저의 다중 프로세스 아키텍처

### 주요 프로세스들
- **브라우저 프로세스**: UI, 네트워킹, 파일 접근 관리
- **렌더러 프로세스**: 웹 페이지 렌더링 (각 탭마다 별도 프로세스)
- **GPU 프로세스**: GPU 관련 작업 처리
- **플러그인 프로세스**: 플러그인 실행
- **유틸리티 프로세스**: 확장 프로그램 등

### 장점
- **안정성**: 한 탭의 오류가 다른 탭에 영향 주지 않음
- **보안**: 프로세스 간 격리로 보안 강화
- **성능**: 멀티코어 CPU 활용 가능

## 웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가

> 💡 _사용자는 로드가 빠르고 상호작용이 원활한 컨텐츠로 이루어진 웹 경험을 원합니다. 
> 따라서 개발자는 이 두 가지 목표를 달성하기 위해서 부단히 노력해야합니다._ 
>  _실제 성능 및 체감되는 성능을 향상시키는 방법을 이해하기 위해서 
> 브라우저가 어떻게 동작하는지 이해하는 것이 도움이 됩니다._
>
> — [MDN Web Docs: How browsers work](https://developer.mozilla.org/ko/docs/Web/Performance/Guides/How_browsers_work)
>

브라우저의 동작은 크게 탐색, 구문 분석, 렌더링 세 단계로 나뉜다.

## 1. 탐색(Navigation)
웹페이지를 로딩하는 첫 단계로, 사용자가 주소창에 URL을 입력하거나, 링크를 클릭하고, 폼을 제출하는 등 동작을 통해 요청을 보낼 때마다 발생한다.

### 1) DNS 조회
1. **DNS 조회**: URL 주소를 입력하고 엔터를 쳤을 때 네비게이션 프로세스가 시작된다.
DNS 서버는 전화번호부와 같은 역할을 하며, URL에 해당하는 IP 주소를 저장하고 있는 서버라고 생각하면 쉽다.
2. **TCP 핸드셰이크**: 한 번도 방문한 적이 없는 사이트라면 DNS 조회가 필요하다.
브라우저는 DNS 조회를 요청하여 IP를 받아 서버와 3번의 패킷 전달 즉, TCP 핸드셰이크를 통해 연결을 설정한다.
3. **TLS 협상**: HTTPS를 통해 보안성있는 연결을 위해서는 암호화된 통신을 위해 또다른 핸드셰이크인 TLS 협상을 진행한다.
이 핸드셰이크는 통신 암호화에 쓰일 암호를 결정하고, 서버를 확인하고, 실제 데이터 전송 전에 안전한 연결이 이루어지도록 한다. 
실제 요청 전에 클라이언트에서 서버로 3번 더 왕복하게된다.
4. **HTTP 요청**: TCP 핸드셰이크를 통해 브라우저와 서버가 견고하게 연결되었음을 확인하고 브라우저는 HTTP GET 요청을 보내고 서버가 요청을 받으면, 관련 응답 해더와 함께 HTML의 내용을 응답하게 된다.

## 2. 구문 분석(Parsing)
브라우저가 첫 번째 데이터의 청크를 받으면, 브라우저의 렌더링 엔진은 수신된 정보를 **파싱**이라는 과정을 통해 브라우저가 이해할 수 있는 구조로 변환하기 시작한다.

### 1) DOM 생성
브라우저가 HTML 파일을 받으면 이 파일을 이진 형태인 **바이트(byte)**단위로 읽기 시작한다. 
브라우저의 HTML 파서(parser)는 이 바이트들을 인코딩 정보(head의 meta charset 정보)를 토대로 **문자**로 변환하고, 이 문자들을 다시 의미를 가진 최소 단위인 **토큰**으로 변환한다.
이 HTML 토큰들은 각각 태그와 그 안의 텍스트, 속성 등을 의미하는데 브라우저는 이를 기반으로 **DOM 트리**를 생성한다.
DOM 트리는 HTML 문서의 구조를 트리 형태로 표현한 것으로, 각 태그가 **노드(Node)**가 되어 부모-자식 관계를 형성한다.

### 2) CSSOM(CSS Object Model) 생성
브라우저는 CSS 파일을 파싱(parsing)하여 CSS 파일 역시 바이트로 전송되므로 브라우저는 이를 문자로 변환한 뒤 CSS 규칙으로 나눈다.
각 CSS 규칙은 선택자와 선언으로 구성되는데 선택자는 스타일을 적용할 HTML 요소를 정의하고, 선언은 적용할 스타일을 정의한다.
브라우저는 이 CSS 규칙들을 기반으로 CSSOM 트리를 생성한다.
CSSOM 트리는 DOM트리와 유사하게 트리구조를 가지며, 각 노드는 해당 노드에 적용될 스타일 정보를 포함한다. 

### 3) 자바스크립트 컴파일
자바스크립트 엔진(V8, SpiderMonkey 등)은 다음과 같은 과정을 거쳐 코드를 실행한다:
1. **파싱**: 소스 코드를 토큰으로 분해하고 AST(추상 구문 트리) 생성
2. **컴파일**: AST를 바이트코드로 변환
3. **최적화**: 자주 사용되는 코드를 기계어로 컴파일 (JIT 컴파일)
4. **실행**: 바이트코드 또는 기계어 실행

JavaScript 실행 중 DOM/CSSOM 변경이 발생하면 렌더링 프로세스가 다시 시작된다.

### 4) 렌더 트리 생성
브라우저는 DOM 트리와 CSSOM 트리를 결합하여 렌더트리를 생성한다. 생성된 렌더 트리는 화면에 실제로 표시될 요소들로만 구성된다. 
(예: `display: none`은 렌더 트리에 미포함, `visibility: hidden`은 렌더 트리에 포함)
렌더 트리의 각 노드는 DOM트리의 요소와 연결되며, CSSOM 트리에서 해당 요소에 적용된 스타일 정보를 포함한다.
즉, 렌더 트리는 HTML 문서 구조와 각 요소의 스타일 정보를 모두 포함한 트리이다.

## 3. 렌더링(Rendering)

### 1. 레이아웃
렌더 트리가 생성된 후 브라우저가 이 트리를 사용해 각 요소의 정확한 **위치와 크기를 계산**하는 과정이다.
레이아웃 과정에서는 렌더 트리의 각 노드가 화면의 어디에 위치할지, 얼마나 클지를 계산한다.
이 계산은 뷰포트 크기와 같은 정보에 의존하는데, 만약 화면 크기가 변경되면 
브라우저는 레이아웃 과정을 다시 수행해야한다. 이 과정을 **리플로우**라고 한다.
리플로우는 성능에 영향을 줄 수 있으므로 이를 최소화하는 것이 중요하다.

### 2. 페인팅
레이아웃 과정이 끝난 후 브라우저가 각 요소를 실제로 화면에 그리는 작업을 시작하는 과정이다.
페인팅 단계에서는 텍스트, 색상, 그림자, 이미지 등 모든 시각적 요소가 화면에 그려진다.
페인팅은 화면에 표시될 그래픽 요소를 생성하는 과정이기 때문에 이 과정도 성능에 큰 영향을 줄 수 있다.
특히, 복잡한 애니메이션이나 그래픽이 포함된 경우 페인트 작업이 많아져 성능이 저하될 수 있다.

### 3. 컴포지팅
브라우저가 화면에 그려질 요소들을 각각의 레이어로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성하는 과정이며, 
GPU를 활용하여 각 레이어를 빠르게 합성한다.
`transform`과 `opacity`와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고 이 컴포지팅 단계에서만 처리되기 때문에 
이러한 속성을 사용하는 애니메이션은 더 부드럽고 빠르게 실행될 수 있다.
컴포지팅 단계는 GPU 가속을 활용하여 성능을 최적화하고, 화면에 최종적으로 표시되는 결과를 빠르게 생성하는데 중요한 역할을 한다.

## Critical Rendering Path (중요 렌더링 경로)

웹 페이지가 화면에 표시되기까지의 최소한의 단계들:

1. **HTML 파싱** → DOM 생성
2. **CSS 파싱** → CSSOM 생성  
3. **JavaScript 실행** (필요시)
4. **렌더 트리 생성** → DOM + CSSOM 결합
5. **레이아웃** → 요소 위치/크기 계산
6. **페인팅** → 픽셀 그리기
7. **컴포지팅** → 레이어 합성

### 최적화 팁
- CSS는 `<head>`에 배치하여 렌더링 차단 방지
- JavaScript는 `async`/`defer` 속성 활용 (프리로드 스캐너에 의해 먼저 실행되어 렌더링 차단 방지)
- 중요하지 않은 리소스는 지연 로딩
  
## JavaScript 실행과 렌더링의 관계

### 이벤트 루프와 렌더링
- JavaScript 실행이 완료되면 렌더링 프로세스가 시작됨
- `requestAnimationFrame`을 사용하여 렌더링 최적화 가능
- 무한 루프나 긴 작업은 렌더링을 차단할 수 있음