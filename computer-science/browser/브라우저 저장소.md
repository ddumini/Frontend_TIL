# 브라우저 저장소

> 웹 브라우저에서 데이터를 저장하고 관리하는 세 가지 주요 방법: 쿠키, 로컬스토리지, 세션스토리지

- 브라우저 저장소는 클라이언트 측에서 데이터를 저장하고 관리하는 메커니즘이다.
- HTTP는 요청과 응답으로 이뤄지는 하나의 사이클이 끝나면,
  연결이 끊어지는 무상태성을 띄어서 클라이언트의 상태를 보존하지 않는다.
- 클라이언트의 상태를 서버가 아닌 클라이언트에 저장해두고 필요시마다 데이터를 꺼내서
  서버에 전달하는 방식으로 HTTP으이 단점을 보완하고자 쿠키와 웹 스토리지를 사용한다.

## 🍪 쿠키 (Cookie)

만료 기간이 있는 클라이언트 단에 저장하는 작은 텍스트 파일로
요청과 응답만이 존재했던 HTTP 웹세계에서 서버와 클라이언트가 주고 받은 내역을 기억하고 불러올 수 있는 혁신적인 역할 수행.

### 특징

#### 장점

- 대부분의 브라우저가 지원
- **서버 통신**: 모든 HTTP 요청에 자동으로 포함
- **지속성**: 만료 시간 설정 가능 (세션 쿠키 vs 영구 쿠키)

#### 단점

- **용량 제한**: 쿠키당 최대 4KB, 도메인당 최대 50개 (브라우저별 차이)
- 매번 서버에 HTTP 요청시 같이 전달되어 서버에 부담
- 암호화가 안되어 민감한 데이터 저장 불가
- CRSF(사이트 간 요청 위조) 위협 - 공격자가 사용자의 요청을 가로채 사용자의 의지와 상관 없이 보안적으로 위험한 행동을 하게끔 변조하여 부당 이익을 취하는 행위
- 문자열만 저장 가능

### 동작 원리

1. 클라이언트가 서버에 HTTP 요청
2. 서버가 HTTP 응답시 set-cookie를 통해 쿠키 생성하여 전달
3. 클라이언트는 이제부터 매 HTTP시 HTTP 헤더에 쿠키 담아서 전송
4. 만료 기간 전이라면, 쿠키는 브라우저에 저장되어 있으며, 항상 요청시 사용 가능
5. 만료됐다면 클라이언트가 새로 서버에 요청하여 쿠키 새로 발급

### 동작 방식

```jsx
import { useState, useEffect } from 'react';

// 쿠키 관련 커스텀 훅
function useCookie(name, defaultValue = '') {
  const [value, setValue] = useState(() => {
    // 쿠키 읽기 함수
    const getCookie = (cookieName) => {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${cookieName}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    };

    return getCookie(name) || defaultValue;
  });

  const setCookie = (newValue, options = {}) => {
    const {
      expires = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1년
      path = '/',
      secure = true,
      sameSite = 'strict',
    } = options;

    document.cookie = `${name}=${newValue}; expires=${expires.toUTCString()}; path=${path}; ${
      secure ? 'secure;' : ''
    } samesite=${sameSite}`;
    setValue(newValue);
  };

  const deleteCookie = () => {
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
    setValue('');
  };

  return [value, setCookie, deleteCookie];
}

// 쿠키 사용 예시 컴포넌트
function CookieExample() {
  const [username, setUsername, deleteUsername] = useCookie('username');

  return (
    <div>
      <p>현재 사용자: {username || '없음'}</p>
      <button onClick={() => setUsername('john')}>사용자 설정</button>
      <button onClick={deleteUsername}>사용자 삭제</button>
    </div>
  );
}
```

### 보안 속성

- **Secure**: HTTPS에서만 전송
- **HttpOnly**: JavaScript 접근 차단 (XSS 방지)
- **SameSite**: CSRF 공격 방지 (Strict, Lax, None)

### 사용 사례

- 사용자 인증 토큰
- 세션 관리
- 사용자 선호도 설정
- 추적 및 분석

## 웹 스토리지란?

- 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 나온 새로운 방식의 데이터 저장소
- 로컬 스토리지와 세션 스토리지 존재
- key, value 쌍의 형태로 저장
- window 객체의 프로퍼티로 존재
- 문자열 외에도 자바스크립트 모든 원시형 데이터와 객체 저장 가능
- HTML5를 지원하는 브라우저만 사용 가능
- XSS(Cross-Site Scripting)로부터 위험

## 💾 로컬스토리지 (LocalStorage)

### 특징

- **용량 제한**: 도메인당 5-10MB (브라우저별 차이)
- **지속성**: 명시적으로 삭제하기 전까지 영구 보존
- **서버 통신**: 서버로 자동 전송되지 않음

### 동작 방식

```jsx
import { useState, useEffect } from 'react';

// 로컬스토리지 커스텀 훅
function useLocalStorage(key, initialValue) {
  // 초기값 설정
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`로컬스토리지 읽기 오류: ${error}`);
      return initialValue;
    }
  });

  // 값 설정 함수
  const setValue = (value) => {
    try {
      // 함수인 경우 현재 값을 인자로 전달
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`로컬스토리지 저장 오류: ${error}`);
    }
  };

  // 값 삭제 함수
  const removeValue = () => {
    try {
      window.localStorage.removeItem(key);
      setStoredValue(initialValue);
    } catch (error) {
      console.error(`로컬스토리지 삭제 오류: ${error}`);
    }
  };

  return [storedValue, setValue, removeValue];
}

// 로컬스토리지 사용 예시 컴포넌트
function LocalStorageExample() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [user, setUser, removeUser] = useLocalStorage('user', null);

  return (
    <div>
      <div>
        <p>현재 테마: {theme}</p>
        <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>테마 변경</button>
      </div>

      <div>
        <p>사용자 정보: {user ? JSON.stringify(user) : '없음'}</p>
        <button onClick={() => setUser({ name: 'John', age: 30 })}>사용자 설정</button>
        <button onClick={removeUser}>사용자 삭제</button>
      </div>
    </div>
  );
}
```

### 브라우저 지원

- **모든 모던 브라우저**: Chrome 4+, Firefox 3.5+, Safari 4+, IE 8+
- **모바일**: iOS Safari 3.2+, Android 2.1+

### 사용 사례

- 사용자 설정 및 선호도
- 애플리케이션 상태 저장
- 오프라인 데이터 캐싱
- 장바구니 정보

## 🔄 세션스토리지 (SessionStorage)

### 특징

- **용량 제한**: 도메인당 5-10MB (로컬스토리지와 동일)
- **지속성**: 브라우저 탭/창이 닫히면 자동 삭제
- **서버 통신**: 서버로 자동 전송되지 않음

### 동작 방식

```jsx
import { useState, useEffect } from 'react';

// 세션스토리지 커스텀 훅
function useSessionStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.sessionStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`세션스토리지 읽기 오류: ${error}`);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.sessionStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`세션스토리지 저장 오류: ${error}`);
    }
  };

  const removeValue = () => {
    try {
      window.sessionStorage.removeItem(key);
      setStoredValue(initialValue);
    } catch (error) {
      console.error(`세션스토리지 삭제 오류: ${error}`);
    }
  };

  return [storedValue, setValue, removeValue];
}

// 다단계 폼 예시 컴포넌트
function MultiStepForm() {
  const [currentStep, setCurrentStep] = useSessionStorage('currentStep', 1);
  const [formData, setFormData] = useSessionStorage('formData', {
    step1: {},
    step2: {},
    step3: {},
  });

  const updateFormData = (step, data) => {
    setFormData((prev) => ({
      ...prev,
      [step]: { ...prev[step], ...data },
    }));
  };

  const nextStep = () => {
    if (currentStep < 3) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
    }
  };

  const resetForm = () => {
    setCurrentStep(1);
    setFormData({ step1: {}, step2: {}, step3: {} });
  };

  return (
    <div>
      <h3>다단계 폼 (단계: {currentStep}/3)</h3>

      {currentStep === 1 && (
        <div>
          <input
            placeholder='이름'
            value={formData.step1.name || ''}
            onChange={(e) => updateFormData('step1', { name: e.target.value })}
          />
        </div>
      )}

      {currentStep === 2 && (
        <div>
          <input
            placeholder='이메일'
            value={formData.step2.email || ''}
            onChange={(e) => updateFormData('step2', { email: e.target.value })}
          />
        </div>
      )}

      {currentStep === 3 && (
        <div>
          <p>입력된 정보:</p>
          <pre>{JSON.stringify(formData, null, 2)}</pre>
        </div>
      )}

      <div>
        <button onClick={prevStep} disabled={currentStep === 1}>
          이전
        </button>
        <button onClick={nextStep} disabled={currentStep === 3}>
          다음
        </button>
        <button onClick={resetForm}>초기화</button>
      </div>
    </div>
  );
}

// 페이지 상태 복원 훅
function usePageState(key) {
  const [state, setState] = useSessionStorage(key, null);

  // 컴포넌트 언마운트 시 상태 저장
  useEffect(() => {
    return () => {
      // 정리 작업이 필요한 경우
    };
  }, []);

  return [state, setState];
}
```

### 탭 격리

- 각 브라우저 탭/창마다 독립적인 저장소
- 같은 도메인이라도 탭 간 데이터 공유 불가
- 새 탭에서 링크를 열면 세션스토리지는 복사되지 않음

### 사용 사례

- 다단계 폼의 임시 데이터
- 페이지 새로고침 시 상태 복원
- 일회성 사용자 입력 보존
- 임시 캐시 데이터

## 상세 비교표

| 특성                | 쿠키                       | 로컬스토리지     | 세션스토리지       |
| ------------------- | -------------------------- | ---------------- | ------------------ |
| **최대 용량**       | 4KB/쿠키                   | 5-10MB/도메인    | 5-10MB/도메인      |
| **지속성**          | 만료 시간까지              | 명시적 삭제까지  | 탭 종료까지        |
| **서버 전송**       | 자동 전송                  | 전송 안됨        | 전송 안됨          |
| **접근 범위**       | 도메인/경로 기반           | 도메인 기반      | 탭별 격리          |
| **JavaScript 접근** | document.cookie            | localStorage API | sessionStorage API |
| **보안 옵션**       | Secure, HttpOnly, SameSite | 없음             | 없음               |
| **브라우저 지원**   | 모든 브라우저              | IE 8+            | IE 8+              |
| **성능 영향**       | 네트워크 오버헤드          | 없음             | 없음               |

## 선택 가이드

### 쿠키를 선택해야 하는 경우

- 서버에서 데이터에 접근해야 할 때
- 사용자 인증/세션 관리
- 작은 크기의 설정값 (4KB 이하)
- 만료 시간이 중요한 데이터

### 로컬스토리지를 선택해야 하는 경우

- 대용량 데이터 저장 (5MB+)
- 브라우저 종료 후에도 유지되어야 하는 데이터
- 클라이언트 전용 데이터
- 사용자 설정, 테마, 언어 등

### 세션스토리지를 선택해야 하는 경우

- 임시 데이터 저장
- 페이지 새로고침 시에만 유지하면 되는 데이터
- 탭별로 독립적이어야 하는 데이터
- 폼 입력값, 위저드 단계 등

## 보안 고려사항

### 공통 주의사항

- **민감한 정보 저장 금지**: 비밀번호, 신용카드 정보 등
- **XSS 공격 대비**: 사용자 입력값 검증 및 이스케이프
- **데이터 암호화**: 필요시 클라이언트 측 암호화 적용

### 쿠키 보안

```javascript
// 보안 쿠키 설정 예시
document.cookie = 'sessionId=abc123; Secure; HttpOnly; SameSite=Strict; Max-Age=3600';
```

### Web Storage 보안

- 동일 출처 정책(Same-Origin Policy) 적용
- HTTPS 사용 권장
- 정기적인 데이터 정리

## 실제 사용 예시

<details>
<summary>사용자 설정 관리</summary>

```jsx
import { useLocalStorage } from './hooks/useLocalStorage';

function ThemeProvider({ children }) {
  const [theme, setTheme] = useLocalStorage('userTheme', 'light');

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  return (
    <div className={`theme-${theme}`}>
      <button onClick={toggleTheme}>{theme === 'light' ? '🌙' : '☀️'} 테마 변경</button>
      {children}
    </div>
  );
}

// 사용자 선호도 관리
function UserPreferences() {
  const [preferences, setPreferences] = useLocalStorage('userPreferences', {
    language: 'ko',
    notifications: true,
    autoSave: true,
  });

  const updatePreference = (key, value) => {
    setPreferences((prev) => ({ ...prev, [key]: value }));
  };

  return (
    <div>
      <h3>사용자 설정</h3>
      <label>
        언어:
        <select value={preferences.language} onChange={(e) => updatePreference('language', e.target.value)}>
          <option value='ko'>한국어</option>
          <option value='en'>English</option>
        </select>
      </label>

      <label>
        <input
          type='checkbox'
          checked={preferences.notifications}
          onChange={(e) => updatePreference('notifications', e.target.checked)}
        />
        알림 받기
      </label>

      <label>
        <input
          type='checkbox'
          checked={preferences.autoSave}
          onChange={(e) => updatePreference('autoSave', e.target.checked)}
        />
        자동 저장
      </label>
    </div>
  );
}
```

</details>

<details>
<summary>폼 데이터 임시 저장</summary>

```jsx
import { useSessionStorage } from './hooks/useSessionStorage';
import { useEffect } from 'react';

function ContactForm() {
  const [formData, setFormData] = useSessionStorage('contactForm', {
    name: '',
    email: '',
    message: '',
  });

  const handleInputChange = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      // API 호출
      await submitForm(formData);

      // 성공 시 세션스토리지 클리어
      setFormData({ name: '', email: '', message: '' });
      alert('폼이 성공적으로 제출되었습니다!');
    } catch (error) {
      alert('제출 중 오류가 발생했습니다.');
    }
  };

  // 페이지 이탈 시 경고
  useEffect(() => {
    const hasUnsavedData = Object.values(formData).some((value) => value.trim() !== '');

    const handleBeforeUnload = (e) => {
      if (hasUnsavedData) {
        e.preventDefault();
        e.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [formData]);

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>이름:</label>
        <input type='text' value={formData.name} onChange={(e) => handleInputChange('name', e.target.value)} required />
      </div>

      <div>
        <label>이메일:</label>
        <input
          type='email'
          value={formData.email}
          onChange={(e) => handleInputChange('email', e.target.value)}
          required
        />
      </div>

      <div>
        <label>메시지:</label>
        <textarea
          value={formData.message}
          onChange={(e) => handleInputChange('message', e.target.value)}
          rows={4}
          required
        />
      </div>

      <button type='submit'>제출</button>
      <button type='button' onClick={() => setFormData({ name: '', email: '', message: '' })}>
        초기화
      </button>
    </form>
  );
}
```

</details>

<details>
<summary>인증 토큰 관리</summary>

```jsx
import { createContext, useContext, useEffect, useState } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // 쿠키에서 토큰 읽기 (HttpOnly 쿠키는 JavaScript로 접근 불가)
  // 실제로는 서버에서 설정하고 API 호출로 사용자 정보 확인
  useEffect(() => {
    const checkAuth = async () => {
      try {
        // API 호출로 현재 사용자 정보 확인
        const response = await fetch('/api/auth/me', {
          credentials: 'include', // 쿠키 포함
        });

        if (response.ok) {
          const userData = await response.json();
          setUser(userData);
        }
      } catch (error) {
        console.error('인증 확인 오류:', error);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (credentials) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
        credentials: 'include',
      });

      if (response.ok) {
        const userData = await response.json();
        setUser(userData);
        return { success: true };
      } else {
        return { success: false, error: '로그인 실패' };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
      setUser(null);
    } catch (error) {
      console.error('로그아웃 오류:', error);
    }
  };

  const value = {
    user,
    login,
    logout,
    loading,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth는 AuthProvider 내에서 사용해야 합니다');
  }
  return context;
}

// 사용 예시
function LoginForm() {
  const { login } = useAuth();
  const [credentials, setCredentials] = useState({ email: '', password: '' });

  const handleSubmit = async (e) => {
    e.preventDefault();
    const result = await login(credentials);

    if (!result.success) {
      alert(result.error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type='email'
        placeholder='이메일'
        value={credentials.email}
        onChange={(e) => setCredentials((prev) => ({ ...prev, email: e.target.value }))}
      />
      <input
        type='password'
        placeholder='비밀번호'
        value={credentials.password}
        onChange={(e) => setCredentials((prev) => ({ ...prev, password: e.target.value }))}
      />
      <button type='submit'>로그인</button>
    </form>
  );
}
```

</details>

## 정리

- 쿠키: 일시적으로 필요한 가벼운 데이터 저장이 필요할 때
  - 다시 보지 않음 쿠키 팝업창, 로그인 자동 완성
- 로컬 스토리지: 지속적으로 필요한 데이터 저장이 필요할 때
  - 자동 로그인
- 세션 스토리지: 일시적으로 필요한 데이터 저장이 필요할 때
  - 일회성 로그인, 입력 폼 저장, 비로그인 장바구니

## 참고 자료

- [MDN Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)
- [MDN HTTP Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [RFC 6265 - HTTP State Management Mechanism](https://tools.ietf.org/html/rfc6265)
- [W3C Web Storage Specification](https://www.w3.org/TR/webstorage/)
