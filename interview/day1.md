# 면접 질문 day1

## 1. CSS의 Cascading에 대해 설명해 주세요.
**"CSS의 Cascading은 '폭포수'라는 뜻으로, 여러 스타일 규칙이 같은 요소에 적용될 때 어떤 스타일이 최종적으로 적용될지를 결정하는 메커니즘입니다.**

**Cascading은 크게 3가지 원칙에 따라 작동합니다.**

**첫째, 중요도(Importance)입니다.** !important > 인라인 스타일 > 작성자 스타일시트(개발자가 작성한 CSS) > 사용자 스타일시트(브라우저에서 사용자가 설정한 스타일) > 사용자 에이전트 스타일시트(브라우저 기본 스타일) 순으로 우선순위가 결정됩니다. 하지만 !important는 유지보수를 어렵게 만들기 때문에 가급적 사용을 피하는 것이 좋습니다.

**둘째, 명시도(Specificity)입니다.**

선택자의 구체적인 정도에 따라 우선순위가 결정되며, 계산 방식은 다음과 같습니다:

- 인라인 스타일: 1000점
- ID 선택자: 100점
- 클래스, 속성, 가상클래스 선택자: 10점
- 요소, 가상요소 선택자: 1점

예를 들어 #header .nav a는 111점(100+10+1)이 되어 div a(2점)보다 우선 적용됩니다.

**셋째, 소스 순서(Source Order)입니다.** 중요도와 명시도가 같을 때는 나중에 작성된 스타일이 적용됩니다.

**실제 업무에서는 이 원리를 이해하고 있어야 스타일 충돌 문제를 효율적으로 해결할 수 있습니다.** 특히 브라우저 기본 스타일을 오버라이드하거나, 써드파티 라이브러리와 커스텀 스타일이 충돌할 때 이 원칙을 바탕으로 문제를 진단하고 해결할 수 있습니다.

## 2. 시맨틱 태그를 사용하면 좋은 점을 설명해 주세요.
**시맨틱 태그를 사용하면 크게 4가지 측면에서 장점이 있습니다.**

**첫째, SEO 최적화입니다.** 검색엔진이 페이지의 구조와 내용을 더 정확하게 이해할 수 있어 검색 결과 상위 노출에 유리합니다. 예를 들어 `<article>`, `<section>`, `<header>` 태그처럼 마크다운에서 HTML 태그를 사용할 때는 꺾쇠 괄호(`<`, `>`)를 그대로 입력하거나, 코드 블록(`\``)으로 감싸면 태그명이 올바르게 표시됩니다.

**둘째, 웹 접근성 향상입니다.** 스크린 리더와 같은 보조 기술이 페이지 구조를 올바르게 해석할 수 있도록 `<nav>`, `<main>`, `<aside>` 등 시맨틱 태그를 사용하면, 마크다운에서도 동일하게 `<nav>`, `<main>`, `<aside>`와 같이 입력해주면 됩니다.

**셋째, 코드 가독성과 유지보수성이 크게 향상됩니다.** `<div>`만 사용할 때보다 태그 이름을 명확히 작성하면 해당 영역의 역할을 쉽게 파악할 수 있습니다. 마크다운에서는 `<div>`, `<header>` 등 HTML 태그를 직접 입력해도 렌더링에 반영됩니다.

**넷째, 브라우저의 기본 기능을 활용할 수 있습니다.** 예를 들어 `<button>` 태그는 기본적으로 키보드 포커스와 클릭 이벤트를 지원하지만, `<div>`를 버튼처럼 사용할 경우 이런 기능을 직접 구현해야 합니다. 마크다운에서도 `<button>` 태그를 그대로 입력하면 HTML로 변환되어 동작합니다.

## 3. 사용자가 브라우저 font-size를 변경하였을 때, 이에 대응해서 웹 화면의 요소가 크거나 작아지도록 하려면 어떻게 스타일링 하면 좋을까요?
**사용자가 브라우저에서 font-size를 변경했을 때 웹 화면이 적절히 대응하려면 상대 단위를 사용해야 합니다.**

**주요 상대 단위의 종류와 역할**

**첫째, rem(root em)입니다.** 루트 요소(html)의 font-size를 기준으로 하는 단위로, 브라우저 기본 font-size 변경에 가장 잘 반응합니다. 1rem = 브라우저 기본 font-size(보통 16px)이므로, 사용자가 브라우저에서 글꼴 크기를 150%로 변경하면 1rem = 24px이 됩니다.

**둘째, em입니다.** 부모 요소의 font-size를 기준으로 하는 단위입니다. 중첩된 요소에서 사용하면 계산이 복잡해질 수 있어, 주로 padding, margin 등에서 해당 요소의 font-size에 비례하는 여백을 만들 때 사용합니다.

**셋째, % (퍼센트)입니다.** 부모 요소를 기준으로 하는 상대 단위로, width나 height에서 주로 사용됩니다.

**넷째, 뷰포트 단위(vw, vh, vmin, vmax)입니다.** 뷰포트 크기에 따라 변하는 단위로, 반응형 디자인에서 유용합니다.

**px을 rem으로 변환하는 방법**

**가장 효율적인 방법은 CSS에서 html 요소의 font-size를 10px로 설정하는 것입니다:**

```css
html {
  font-size: 62.5%; /* 16px의 62.5% = 10px */
}
```

**이렇게 하면 계산이 매우 간단해집니다:**

- 12px → 1.2rem
- 16px → 1.6rem
- 20px → 2.0rem

## 4. position의 속성들과 각각의 특징을 설명해 주세요.
`static`, `relative`, `absolute`, `fixed`, `sticky` 가 있습니다.

**1. static (기본값)**

**문서의 일반적인 흐름에 따라 배치됩니다.** top, right, bottom, left 속성이 적용되지 않으며, z-index도 작동하지 않습니다. 모든 요소의 기본 상태입니다.

**2. relative**

**요소가 원래 있어야 할 위치를 기준으로 상대적으로 이동합니다.** 원래 자리는 그대로 차지하고 있어서 다른 요소들에게 영향을 주지 않습니다. top, left 등으로 이동시킬 수 있고, 자식 요소의 absolute 위치 지정 시 기준점이 됩니다.

**3. absolute**

**가장 가까운 positioned 부모 요소(static이 아닌)를 기준으로 절대 위치가 결정됩니다.** 문서 흐름에서 완전히 제거되어 다른 요소들이 해당 공간을 차지합니다. positioned 부모가 없으면 html 요소를 기준으로 합니다.

**4. fixed**

**뷰포트(브라우저 창)를 기준으로 절대 위치가 결정됩니다.** 스크롤해도 항상 같은 위치에 고정되어 있습니다. 주로 헤더, 사이드바, 플로팅 버튼 등에 사용됩니다.

**5. sticky**

**relative와 fixed의 특성을 합친 것으로, 스크롤 위치에 따라 동작이 바뀝니다.** 설정된 임계값에 도달하기 전까지는 relative처럼 동작하다가, 임계값에 도달하면 fixed처럼 고정됩니다.

## 5. Git에서 branch merge 방법들과 각 방법의 특징을 설명해 주세요.
**Git에서 브랜치를 병합하는 방법은 크게 3가지가 있으며, 각각 다른 특징과 사용 목적을 가지고 있습니다.**

**1. Merge (일반 병합)**

**두 브랜치의 변경사항을 합치면서 새로운 merge commit을 생성하는 방법입니다.**

```bash
git merge feature-branch
```

**특징:**

- 브랜치의 전체 히스토리가 보존됩니다
- Merge commit이 생성되어 언제 어떤 브랜치가 병합되었는지 명확히 알 수 있습니다
- 비선형적인 히스토리 구조를 만듭니다
- 충돌 발생 시 한 번에 해결할 수 있습니다

**2. Rebase**

**현재 브랜치의 커밋들을 대상 브랜치의 최신 커밋 뒤로 재배치하는 방법입니다.**

```bash
git rebase main
```

**특징:**

- 선형적이고 깔끔한 히스토리를 만듭니다
- Merge commit이 생성되지 않습니다
- 커밋 해시가 변경되므로 이미 push된 브랜치에서는 주의가 필요합니다
- 각 커밋마다 충돌을 해결해야 할 수 있습니다

**3. Squash and Merge**

**여러 커밋을 하나의 커밋으로 압축해서 병합하는 방법입니다.**

shellscriptApply to page.tsx

```bash
git merge --squash feature-branch

git commit -m "Add new feature"
```

**특징:**

- 기능 단위로 깔끔한 히스토리를 유지할 수 있습니다
- 세부적인 작업 커밋들이 사라져 메인 브랜치가 정리됩니다
- 기능별 rollback이 쉬워집니다
- 협업 시 개발 과정보다는 결과에 집중할 수 있습니다

## 6. Git Flow 브랜치 전략에 대해 설명해 주세요.
Git Flow는 체계적인 브랜치 관리를 위한 전략으로, 크게 5가지 브랜치로 구성됩니다.

**메인 브랜치로는 main과 develop이 있습니다.** main은 실제 배포되는 안정적인 코드만 관리하고, develop은 개발의 중심이 되는 브랜치로 새로운 기능들이 통합되는 곳입니다.

**지원 브랜치로는 feature, release, hotfix가 있습니다.** feature는 새로운 기능을 개발할 때 develop에서 분기해서 작업하고 완료되면 다시 develop으로 병합합니다. release는 배포 준비를 위한 브랜치로 버그 수정만 하고 main과 develop 양쪽에 병합합니다. hotfix는 운영 중 긴급한 버그 수정을 위해 main에서 분기해서 수정 후 양쪽에 병합하는 방식입니다.

장점은 **각 브랜치의 역할이 명확해서 대규모 팀에서 협업하기 좋고, 릴리즈 관리가 체계적**이라는 점입니다. 다만 브랜치가 많아서 복잡하고, 작**은 프로젝트에는 과도**할 수 있습니다.

실제로 팀 프로젝트에서 Git Flow의 개념을 참고했지만, 프로젝트 규모가 작아서 main과 develop, 그리고 feature 브랜치 정도만 사용하는 간소화된 버전으로 진행했습니다. 현재는 GitHub Flow처럼 더 간단한 전략들이 많이 사용되고 있어서, 프로젝트 특성에 맞는 브랜치 전략을 선택하는 것이 중요하다고 생각합니다.