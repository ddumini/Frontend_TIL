# Page Router

- 직관적인 파일 시스템 라우터를 사용하여 각 파일을 경로에 매핑하는 라우팅 방식.
- 폴더 안의 파일 및 폴더 구조에 따라 자동으로 라우팅을 설정해주는 라우터.
- 서버 측에서 페칭한 모든 데이터는 페이지 컴포넌트 최상단에서만 Props로 전달한다.

## Routing

### 파일 & 폴더 기반 라우팅

Page Router 방식을 사용하면 파일 시스템을 기반으로 자동으로 라우팅 매핑을 해준다.

```tsx
export default function Vocs() {
  return <div>VOCS</div>
}
```

```bash
📦 my-next-app/
├─ public/
├─ src/
│  ├─ components/
│  └─ pages/
│     ├─ vocs.tsx
│     └─ vocs.module.css
└─ ETC
```

Next.js 프로젝트 Page Router 방식 폴더 구조에는 pages라는 폴더에 파일을 추가하는 것만으로도 페이지를 생성할 수 있고, 자동으로 주소가 매핑된다.

### 동적 경로 (Dynammic Routes)

동적 세그먼트는 파일 또는 폴더 이름을 대괄호로 감싸서 파일을 생성하면 된다.

```bash
📦 my-next-app/
├─ public/
├─ src/
│  ├─ components/
│  └─ pages/
│     └─ list/
│       └─ [id].tsx // 기본 다이나믹 라우트
│       └─ [...id].tsx // catch-all 라우트
│       └─ [[...id]].tsx // optional catch-all 라우트
└─ ETC
```

세그먼트를 접근하기 위해서 `useRouter`를 사용할 수 있다.

```tsx
import { useRouter } from 'next/router'

export default function ExamplePage() {
  const router = useRouter()
  return <p>{router.query.id}</p>
}
```

### 라우트 전환 & 리다이렉트 (Redirect)

React의 SPA와 유사하게 Link 컴포넌트로 라우트 전환.

```tsx
import Link from 'next/link'
import { useRouter } from 'next/router'

function Home() {
  const router = useRouter()

  return (
    <ul>
      <li>
        <Link href='/voc'>voc page</Link>
      </li>
      <li>
        <Link href='/list/5'>list-5 page</Link>
        {/* push 메서드 사용시 (프로그래밍 방식으로 네비게이트 필요 없다면 Link컴포넌트 권장) */}
        <button type='button' onClick={() => router.push('/voc')}>
          voc으로 이동
        </button>
      </li>
    </ul>
  )
}

export default Home
```

## Data fetching

### getStaticProps

`getStaticProps`는 빌드 시 한 번만 실행되며, 외부 데이터를 fetch하여 정적 페이지를 생성 (Static Generation)하는 함수이다.
return되는 값은 반드시 객체 형태여야 하고, 호출마다 fetch하는 `getServerSideProps`와는 다르게 매번 Data fetch하지 않아서 성능 면에서 좋다.

```tsx
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()

  // 빌드 시점에 posts 데이터를 props로 넘김
  return { props: { data } }
}
```

- 클라이언트에게 페이지를 전달하기 전 API요청을 통해 외부 데이터를 받아온 후 정적 페이지를 생성할 때
- 정적인 페이지 생성을 해야할 때

### getStaticPaths

정적으로 렌더링 할 경로를 설정하기 위한 함수.
이는 페이지에 동적 라우트(Dynamic Route)가 있고 `getStaticProps`를 사용하는 경우 생성할 경로 목록을 정의할 때 사용한다.

즉, 동적 경로를 사용하는 페이지에서 `getStaticPaths`라는 함수를 내보내면 Next.js는 해당 함수에 지정된 모든 경로를 정적으로 미리 렌더링한다.

```tsx
export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } },
      { params: { id: '3' } },
    ],
    fallback: false,
  }
}
```

#### fallback 옵션

- `fallback: false`
  - paths에 없는 경로는 404 페이지를 반환
  - 빌드 시 모든 경로를 미리 생성
  - 사용 예: 경로가 고정적이고 적을 때
- `fallback: true`
  - paths에 없는 경로도 접근 가능 (런타임에 생성)
  - 첫 요청 시 페이지 생성(로딩 상태 필요)
  - 이후 요청은 캐시된 페이지 제공
  - 사용 예: 경로가 많거나 동적으로 추가될 때
- `fallback: 'blocking'`
  - fallback:true와 유사하지만, 첫 요청 시 페이지 생성이 완료될 때까지 대기
  - 로딩 상태 불필요(SSR처럼 동작)
  - 사용 예: SEO가 중요하고 로딩 상태를 보여주고 싶지 않을 때

### getServerSideProps

사용자가 클라이언트로 요청할 때마다 실행되는 함수. 서버사이드에서만 실행되며 클라이언트 사이드에서는 실행되지 않는다.

```tsx
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()
  return { props: { data } }
}
```

getServerSideProps와 getStaticProps 모두 pre-render가 필요한 경우 (SEO 등)에만 사용하도록 권장하는 비슷한 동작의 함수지만 아래와 같은 차이가 존재한다.
| | getStaticProps | getServerSideProps |
| --------- | ----------- | ------------ |
| 호출 횟수 | 빌드 시에 단 한 번 | page가 요청 받을 때마다 (호출 시마다) |
| 렌더링 | SSG | SSR |
| 장점 | 호출 시마다 매번 data fetch를 하지 않으니 <br> getServerSideProps보다 성능 면에서 좋다. | 내용을 언제든지 동적으로 수정이 가능하다. |
| 단점 | 동적으로 계속 수정 불가능 | 매 요청마다 호출되어 성능상 불리하다. |

### Client-side

SEO가 중요하거나 초기 로딩 속도가 중요한 페이지 외에서는 Client-side 방식도 활용할 수 있다.

클라이언트 데이터 페칭은 컴포넌트 레벨에서 사용하며 이는 런타임에 fetching이 진행된다.
이후 데이터의 변경에 따라 컴포넌트의 내용도 업데이트된다.

client-side 방식으로 데이터를 페칭하는 방법은 side effect를 처리하는 useEffect를 사용하면 된다.
(혹은 Tanstack Query 등 라이브러리 사용)

```tsx
export default function ExamplePage() {
  const [data, setData] = useState(null)

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then(res => res.json())
      .then(data => setData(data))
  }, [])
  return <p>{data}</p>
}
```

## Reference

[렌더링 방식](../../computer-science/rendering/렌더링%20방식.md)
