# 서버 컴포넌트

## 서버 컴포넌트 등장 이전과 이후

서버 컴포넌트 등장 이전에는 하이드레이션을 위한 JS Bundle을 전달하는 과정에서 컴포넌트 상호작용이 필요한 컴포넌트만 내보내는 것이 아니라 페이지에 포함된 모든 컴포넌트를 전달했다.
즉, 불필요한 컴포넌트가 번들에 포함되어 전달되었다.

그러나 서버 측에서 단 한 번만 실행되는 리액트 서버 컴포넌트의 등장으로 클라이언트 컴포넌트만 번들링하여 전달할 수 있게 되었다.
따라서 번들 용량을 줄이기 위해 페이지의 대부분은 서버 컴포넌트로 작성하고 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용하는 것이 좋다.

## 주의사항

1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.
   ex) 리액트 훅스, 클라이언트 라이브러리, 이벤트 핸들러 (`useEffect`, `useState`, `useCallback`, `onClick`, `onChange` 등)
2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.
   사전 렌더링을 위해 서버에서 1번 실행, 하이드레이션을 위해 브라우저에서 1번 실행
3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.
   -> import된 서버 컴포넌트는 클라이언트 컴포넌트로 자동으로 변경된다.
   -> 반드시 import해야하는 경우에는 Children Props로 전달한다.
4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다. (함수)
   -> RSC Payload에 포함되려면 직렬화 가능해야하기 때문.

## RSC Payload (React Server Component Payload)

앱라우터 버전의 Next.js 앱에서도 페이지 라우터 버전과 마찬가지로
초기 접속 요청 이후 발생하게 되는 페이지 이동들은 모두 기본적으로 클라이언트사이드 렌더링 방식으로 처리된다. 그러려면 브라우저가 현재 이동할 페이지에 대한 데이터가 필요한데, Client Component의 정보를 포함하는 JS Bundle과 Server Component의 정보를 포함하는 RSC Payload를 함께 전달하게 되어
브라우저에서는 JS Bundle을 실행해서 RSC Payload와 합쳐서 페이지를 적절히 교체할 수 있게 된다.

Next.js의 프리페칭(pre-fetching)에서,
Static 페이지의 경우 RSC Payload와 JS Bundle을 함께 전달하고,
Dynamic 페이지의 경우 RSC Payload만 전달하고, 향후 실제로 페이지 이동이 발생하면 JS Bundle을 프리페칭하여 전달한다.

## 데이터 페칭 (in App Router)

- 서버 컴포넌트는 브라우저가 아니라 서버에서 실행되며, 브라우저로 전송되기 전에 렌더링 결과(JSX -> HTML)를 생성한다.따라서 async/await 키워드를 통해 비동기 함수로써 사용해도 문제가 없다.
  즉, 데이터가 필요한 컴포넌트에서 직접 데이터 요청을 할 수 있다.
- 서버 컴포넌트 이전(Next.js 12 또는 CSR/SSR)의 제약
  - 기본적으로 React 컴포넌트는 클라이언트 컴포넌트로 브라우저에서 실행됨
  - 브라우저 환경에서 컴포넌트 함수는 즉시 실행되어야 하며, async를 쓰면 Promise를 반환하게 되어 문제가 생김
  - React는 JSX = 동기 함수 호출 결과를 기대하는데 async 함수는 `Promise<JSX>`를 반환하므로 에러 발생
  - SSR에서도 async는 getServerSideProps/ getStaticProps에서만 사용 가능
  - 페이지 전체가 렌더링되기 전에만 서버 작업이 가능했으며, 컴포넌트 단위에서는 불가능
