# 리액트 앱의 동작 원리

## 리액트란?

리액트는 페이스북에서 개발한 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리이다.

상태값이 변경되거나, 부모가 재렌더링 될 때마다 UI를 자동으로 업데이트 해주는 JavaScript 라이브러리이다.

- 즉, state 등의 상태값이 변경되거나 부모가 재렌더링 되면, 리액트가 해당 컴포넌트 함수를 자동으로 재호출하여 재렌더링 해준다.

이를 위해 가상DOM을 통해 변경된 부분만 효율적으로 업데이트해주는 구조를 채택했다.

- 가상DOM은 실제 DOM과 동일한 구조를 가지고 있는 JavaScript 객체이다.
- 컴포넌트의 상태값이 변경되면, 새로운 가상DOM 객체를 만들고, 이전 가상DOM 객체와 비교한다.
- 최종적으로 바뀐 부분이 있을 경우, 해당 부분만 실제 DOM에 반영하여 UI를 업데이트 해준다.

## 가상DOM(Virtual DOM)이란?
- 실제 DOM의 구조를 분석하여 객체 형태로 메모리에 저장하고 관리한다.
- 렌더링시마다 새로운 가상DOM을 생성하여, 상태값 변경 이전/이후 달라진 부분을 비교하는 매커니즘을 사용한다.

## 리액트 UI 업데이트 단계

### 1. 렌더 단계(Render Phase)
- 리액트는 렌더링 할 때마다 매번 새로운 가상 DOM을 만들고,
  이전 가상 DOM과 비교하여 바뀐 부분을 탐색하고,
  실제 DOM에 반영할 부분을 결정한다.

### 2. 커밋 단계(Commit Phase)
- 렌더 단계를 거쳐 바꾸기로 결정된 부분만 실제 DOM에 반영한다.
- 브라우저는 변경된 실제 DOM을 화면에 paint 한다.
- 이 때가 didMount, didUpdate가 완료되어 useEffect가 호출되는 시점이다.

## React Element 구조

### JSX
JavaScript XML의 줄임말로, 리액트는 JSX를 기본으로 사용한다.
JSX는 JavaScript 파일 내에서 HTML 태그 등을 사용할 수 있게 만드는 확장 문법이다.

JSX를 사용해 React.Element를 리턴하는 컴포넌트를 출력해보면, JavaScript Object가 출력된다.

### React.createElement
JSX는 빌드 시점에 `React.createElement()` 호출로 변환되며, 이는 React Element 객체를 생성한다.
`React.Element`는 컴포넌트의 타입, 속성, 자식 요소를 포함하며 실제 DOM 요소가 아니라, 메모리에 저장된 객체이고 렌더링 시 실제 DOM 요소로 변환된다.

```javascript
// JSX
<div className="hello">Hello World</div>

// 변환된 결과
React.createElement('div', {className: 'hello'}, 'Hello World')
```

### React component
React component는 어떻게 렌더링할지를 정의하는 함수이다.

### React component Instance
실제로 React Component가 렌더링되어 생성된 구체적인 객체를 의미한다.
컴포넌트의 상태, 생명주기가 관리되는 독립적인 객체를 의미한다.

## Reconciliation (재조정)
React가 Virtual DOM 트리의 변화를 감지하고 실제 DOM에 반영하는 과정이다.

React Element는 단순 Object이기 때문에 이 작업이 매우 빠르게 이루어진다.
이때, 이 React Element들로 이루어진 Tree를 Virtual DOM이라고 하며, 메모리 영역에 저장된다.
처음에는 해당 트리를 전부 DOM에 그려내지만 실제로 그리는 비용은 메모리단에서 JavaScript를 조정하는 비용에 비해 매우 비싸기 때문에 이후에는 변경된 부분만 실제 DOM에 반영한다.

### Diffing
Diffing은 이전 Virtual DOM과 새로운 Virtual DOM을 비교하여 변경된 부분을 찾는 과정이다.
1. 같은 타입의 Element는 유사한 구조를 가진다.
   즉, 그 Element와 그 하위의 모든 Component Instance를 기존 인스턴스에서 제거(언마운트)하고, 새로운 타입의 Component Instance를 만들어 추가(마운트)한다.
2. 리스트의 자식들은 key를 통해 고유하게 식별된다.
   key가 변경되면 React는 해당 Element를 이전과 다른 새로운 요소로 인식하고, 새롭게 마운트한다.
   key의 존재 자체만이 아닌, 같은 위치에서의 key가 다르다면, 두 요소가 서로 다르다고 판단한다.
   이때, 같은 위치란 배열 내에서 같은 인덱스가 아닌, 부모 자식 관계 내에서 key가 어떤 요소를 지칭하는지에 따라 결정된다.

즉, 리스트나 자식 컴포넌트에서 key가 변경되면, 해당 컴포넌트와 그 하위에 있는 모든 컴포넌트 인스턴스가 기존과는 다른 것으로 간주되어 언마운트되고, 새로운 인스턴스로 새롭게 마운트한다. 동일하다면 인스턴스를 재사용하고, 순서를 변경하거나 업데이트한다.

#### Diffing 알고리즘의 핵심 원칙
1. **서로 다른 타입의 요소**: 완전히 새로운 트리로 교체
2. **같은 타입의 요소**: 속성만 업데이트하고 자식 요소들을 재귀적으로 비교
3. **Key 속성**: 리스트의 자식 요소들을 효율적으로 식별

### Batch Update
Batch Update는 여러 개의 상태 변경을 한 번에 처리하는 것을 말한다.
여러 상태 변경이 일어난 후, React는 Diffing 알고리즘을 통해 변경된 부분을 찾아내 실제 DOM에 반영한다. 
즉, DOM 조작 횟수를 줄이는 최적화가 되어있다.

## Rendering과 State Change
React는 자체적으로 브라우저의 DOM이나 네이티브 앱의 UI를 관리하지 않는다.
대신, React는 상태 변경이 일어나면 이를 감지하고, 이에 따라 컴포넌트를 재렌더링하여 실제 DOM에 반영한다.

### React Core
UI의 구조, 상태 관리, 그리고 컴포넌트 생명주기와 관련된 로직을 담고있다.
순수한 JavaScript 라이브러리로 특정 플랫폼에 의존하지 않는다.
Reconciliation 과정을 통해 가상 DOM을 업데이트하고, 이전 상태와 새로운 상태의 차이를 계산해 어떤 부분이 변경되어야 하는지를 결정한다.
setState, Hooks 등의 요청이 발생하면 React Core는 이를 감지하고 여러 업데이트를 모아서 한 번에 처리한다.
이를 통해 렌더링을 줄이고 성능을 최적화한다.

### Renderer
React Core가 생성한 가상 DOM을 실제 사용자 인터페이스로 변환하는 역할을 한다.
브라우저 환경에서는 DOM API를 사용해 실제 HTML 요소를 생성하고 업데이트한다.
모바일 환경이라면 네이티브 UI 컴포넌트를 생성해 iOS, Android 의 네이티브 뷰로 렌더링한다.

## React Fiber
React 16 이전의 Reconciler 알고리즘은 스택 구조로 이루어져 하나의 스택에 작업이 쌓이고, 동기적으로 작업이 이루어졌다.
스택이 빌 때까지 동작하며 작업의 중단이 불가한 특징으로 다른 우선순위가 높은 작업을 먼저 처리할 수 없고, 앱이 무반응 상태가 되거나 프레임 드랍이 발생할 수 있다.
이를 해결하기 위해 React Fiber가 도입되었다.

### Fiber Reconciler
React Element가 JavaScript Object인 것 처럼, Fiber역시 JavaScript Object이다.
- 작업을 작은 단위(chunk)로 나누고, 우선순위를 지정한다.
- 작업을 중단하고 재개할 수 있다.
- 작업을 재사용하거나 불필요하다면 버릴 수 있다.
- 비동기로 동작한다.

Fiber는 React의 작업 단위로서, 각 Fiber 노드에 대해 렌더링 작업(즉 Reconciliation)을 진행한 후, "완료된 작업" 형태로 준비되면 commit 단계에서 실제 DOM에 반영된다.

### Fiber Tree
Fiber Tree는 Fiber 노드들로 이루어진 트리 구조를 말한다.
두 개의 Tree가 존재하며
- 하나는 이전 상태를 가지고 있는 Current Tree이며 DOM 과 동기화 되어 있는, 현재 화면에 보이는 트리이다.
- 하나는 새로운 상태를 가지고 있는 WorkInProgress Tree이며, 실제 비동기 작업이 반영된 트리이다.

비동기 작업들이 모두 완료되면 current와 workInProgress의 포인터를 변경하는 방식으로 작업을 수행해 나간다.

- alternate 속성은 Fiber Tree의 반대 Fiber 요소를 가리키고 이를 통해 Fiber의 재사용을 극대화한다.

Render 단계에서는 Fiber Tree만 만들어내는 것이 아니라 Effect 목록을 만들어낸다.

### React Fiber의 주요 특징
- **Time Slicing**: 작업을 작은 단위로 분할하여 브라우저가 다른 작업을 수행할 시간을 확보
- **우선순위 기반 스케줄링**: 사용자 상호작용과 같은 중요한 업데이트를 우선 처리
- **인터럽트 가능한 렌더링**: 더 중요한 작업이 생기면 현재 작업을 중단하고 나중에 재개

### Effect
DOM 조작, 특정 생명주기 메소드의 호출등을 의미한다.
이 작업들은 다른 Component에 영향을 줄 수 있기 때문에 render 단계에서 실행될 수 없다.
Commit 단계에서 React는 모든 Effect를 확인하며 Component Instance에 반영한다.
이 변화들은 화면에 반영되어야 하기 때문에, 동기적으로, 하나의 연속적인 변경사항으로 이루어진다.
즉, render 단계에서 생성한 Effect 목록에 의해 결정된다.

### ErrorBoundary, Suspense, Concurrent Mode
React Fiber의 도입으로 활용할 수 있는 기능들이다.
1. ErrorBoundary: 오류가 발생하면 오류를 처리하는 컴포넌트이다.
2. Suspense: 비동기 작업이 완료되기 전까지 화면에 보이지 않는 컴포넌트를 렌더링하는 컴포넌트이다.
3. Concurrent Mode: 비동기 작업을 동시에 처리하는 모드이다.

## React Component Lifecycle
리액트의 컴포넌트는 생명주기를 가진다.
생명주기란 컴포넌트가 생성되고 사용되고 소멸될 때 까지 일련의 과정을 말한다.
생명 주기는 생성(mounting) - 업데이트(updating) - 제거(unmounting) 단계로 구성되어져 있는데,
각 단계마다 특정한 이벤트가 발생하며 그 때마다 사용되는 메서드가 있다.
- Mounting: constructor, render, componentDidMount
- Updating: render, componentDidUpdate
- Unmounting: componentWillUnmount

이러한 생명주기 함수는 클래스형 컴포넌트에서만 사용할 수 있으며, 함수형 컴포넌트에서는 Hooks으로 유사한 기능을 활용할 수 있다.

### Mounting
컴포넌트가 처음 DOM에 붙는 시점이다.
초기 state 세팅, 데이터 fetching, 이벤트 구독 등을 수행한다.
- 클래스형: `constructor`, `render`, `componentDidMount`
- 함수형: `useEffect(() => {...}, [])`

### Updating
props나 state가 변경되어 리렌더링이 일어나는 시점이다.
변경된 값을 반영하고 DOM 후처리를 한다. 
- 클래스형: `render`, `componentDidUpdate`
- 함수형: `useEffect(() => {...}, [deps])`

### Unmounting
컴포넌트가 DOM에서 제거되는 시점이다.
타이머나 이벤트 리스너, 구독을 정리(clean-up)해야 메모리 누수를 방지할 수 있다.
- 클래스형: `componentWillUnmount`
- 함수형: 
  ```js
  useEffect(() => {
    return () => {
      // cleanup
    };
  }, []);
  ```

### 기타
- `getSnapshotBeforeUpdate` -> DOM이 업데이트되기 직전의 상태를 캡처해야 할 때 사용하며, 함수형에서는 비슷한 동작을 `useLayoutEffect`로 처리할 수 있다.